import numpy as np
from PIL import Image
from torch.utils import data
import os, cv2, torch, random, io

def load_image_with_cache(path, cache=None, lock=None):
	if cache is not None:
		# if not cache.has_key(path):	#### lk
		if path not in cache:	#### lk
			with open(path, 'rb') as f:
				cache[path] = f.read()
		return Image.open(io.BytesIO(cache[path]))   # StringIO(cache[path]) lk
	return Image.open(path)

# class Data(data.Dataset):
# 	def __init__(self, root, lst, yita=0.5,
# 		mean_bgr = np.array([104.00699, 116.66877, 122.67892]),
# 		crop_size=None, rgb=True, scale=None):
# 		self.mean_bgr = mean_bgr
# 		self.root = root
# 		self.lst = lst
# 		self.yita = yita
# 		self.crop_size = crop_size
# 		self.rgb = rgb
# 		self.scale = scale
# 		self.cache = {}
#
# 		lst_dir = os.path.join(self.root, self.lst)
# 		# self.files = np.loadtxt(lst_dir, dtype=str)
# 		with open(lst_dir, 'r') as f:
# 			self.files = f.readlines()
# 			self.files = [line.strip().split(' ') for line in self.files]
#
# 	def __len__(self):
# 		return len(self.files)
#
# 	def __getitem__(self, index):
# 		data_file = self.files[index]
# 		# load Image
# 		img_file = self.root + data_file[0]
# 		if not os.path.exists(img_file):
# 			img_file = img_file.replace('jpg', 'png')
# 		# img = Image.open(img_file)
# 		img = load_image_with_cache(img_file, self.cache)
# 		# load gt image
# 		gt_file = self.root + data_file[1]
# 		# gt = Image.open(gt_file)
# 		gt = load_image_with_cache(gt_file, self.cache)
# 		if gt.mode == '1':
# 			gt  = gt.convert('L')
# 		# print '############################################################333333333333333333'
# 		# print img, gt
# 		return self.transform(img, gt)
#
# 	def transform(self, img, gt):
# 		gt = np.array(gt, dtype=np.float32)
# 		if len(gt.shape) == 3:
# 			gt = gt[:, :, 0]
# 		gt /= 255.
# 		gt[gt >= self.yita] = 1
# 		gt = torch.from_numpy(np.array([gt])).float()
# 		img = np.array(img, dtype=np.float32)
# 		if self.rgb:
# 			img = img[:, :, ::-1] # RGB->BGR
# 		img -= self.mean_bgr
# 		data = []
# 		if self.scale is not None:
# 			for scl in self.scale:
# 				img_scale = cv2.resize(img, None, fx=scl, fy=scl, interpolation=cv2.INTER_LINEAR)
# 				data.append(torch.from_numpy(img_scale.transpose((2,0,1))).float())
# 			return data, gt
# 		img = img.transpose((2, 0, 1))
# 		img = torch.from_numpy(img.copy()).float()
# 		if self.crop_size:
# 			_, h, w = gt.size()
# 			assert(self.crop_size < h and self.crop_size < w)
# 			i = random.randint(0, h - self.crop_size)
# 			j = random.randint(0, w - self.crop_size)
# 			img = img[:, i:i+self.crop_size, j:j+self.crop_size]
# 			gt = gt[:, i:i+self.crop_size, j:j+self.crop_size]
# 		return img, gt

#######################################################################################################################

class CrackData(data.Dataset):
	def __init__(self, root, lst,
		crop_size=None, rgb=True, scale=None):
		# self.mean_bgr = mean_bgr
		self.root = root
		self.lst = lst
		# self.yita = yita
		self.crop_size = crop_size
		self.rgb = rgb
		self.scale = scale
		self.cache = {}

		lst_dir = os.path.join(self.root, self.lst)
		# self.files = np.loadtxt(lst_dir, dtype=str)
		with open(lst_dir, 'r') as f:
			self.files = f.readlines()
			self.files = [line.strip().split(' ') for line in self.files]

	def __len__(self):
		return len(self.files)

	def __getitem__(self, index):
		data_file = self.files[index]
		# load Image
		img_file = self.root + data_file[0]
		if not os.path.exists(img_file):
			img_file = img_file.replace('jpg', 'png')
		# img = Image.open(img_file)
		img = load_image_with_cache(img_file, self.cache)
		# load gt image
		gt_file = self.root + data_file[1]
		# gt = Image.open(gt_file)
		gt = load_image_with_cache(gt_file, self.cache)
		if gt.mode == '1':
			gt = gt.convert('L')
		# print '############################################################333333333333333333'
		# print img, gt
		return self.transform(img, gt)

	def transform(self, img, gt):
		gt = np.array(gt, dtype=np.float32)
		if len(gt.shape) == 3:
			gt = gt[:, :, 0]
		gt /= 255.
		# gt[gt >= self.yita] = 1
		gt = torch.from_numpy(np.array([gt])).float()
		img = np.array(img, dtype=np.float32)
		if self.rgb:
			img = img[:, :, ::-1] # RGB->BGR
		# img -= self.mean_bgr
		img = img / 255  ######## lk
		data = []
		if self.scale is not None:
			for scl in self.scale:
				img_scale = cv2.resize(img, None, fx=scl, fy=scl, interpolation=cv2.INTER_LINEAR)
				data.append(torch.from_numpy(img_scale.transpose((2,0,1))).float())
			return data, gt

		img = img.transpose((2, 0, 1))

		img = torch.from_numpy(img.copy()).float()
		if self.crop_size:
			_, h, w = gt.size()
			assert(self.crop_size < h and self.crop_size < w)
			i = random.randint(0, h - self.crop_size)
			j = random.randint(0, w - self.crop_size)
			img = img[:, i:i+self.crop_size, j:j+self.crop_size]
			gt = gt[:, i:i+self.crop_size, j:j+self.crop_size]

		return img, gt
